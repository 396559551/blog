(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{506:function(t,s,e){t.exports=e.p+"assets/img/vuex.6435f866.png"},580:function(t,s,e){"use strict";e.r(s);var a=e(6),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("##vuex\n"),a("img",{attrs:{src:e(506),alt:""}})]),t._v(" "),a("h4",{attrs:{id:"_1-store"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-store"}},[t._v("#")]),t._v(" 1）store")]),t._v(" "),a("p",[t._v("vuex 中最关键的是store对象，这是vuex的核心。可以说，vuex这个插件其实就是一个store对象，每个vue应用仅且仅有一个store对象。")]),t._v(" "),a("p",[t._v("（1）创建store")]),t._v(" "),a("p",[t._v("可见，store是Vuex.Store这个构造函数new出来的实例。在构造函数中可以传一个对象参数。这个参数中可以包含5个对象：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("state – 存放状态\n\ngetters – state的计算属性\n\nmutations – 更改状态的逻辑，同步操作\n\nactions – 提交mutation，异步操作\n\nmudules – 将store模块化\n")])])]),a("p",[t._v("关于store，需要先记住两点：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("store 中存储的状态是响应式的，当组件从store中读取状态时，如果store中的状态发生了改变，那么相应的组件也会得到更新；")])]),t._v(" "),a("li",[a("p",[t._v("不能直接改变store中的状态。改变store中的状态的唯一途径是提(commit)mutations。这样使得我们可以方便地跟踪每一个状态的变化。")])])]),t._v(" "),a("h4",{attrs:{id:"_2-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-state"}},[t._v("#")]),t._v(" 2）state")]),t._v(" "),a("p",[t._v("state上存放的，说的简单一些就是变量，也就是所谓的状态。没有使用 state 的时候，我们都是直接在data 中进行初始化的，但是有了 state 之后，我们就把 data 上的数据转移到 state 上去了。另外有些状态是组件私有的状态，称为组件的局部状态，我们不需要把这部分状态放在store中去。")]),t._v(" "),a("h4",{attrs:{id:"_3-getters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-getters"}},[t._v("#")]),t._v(" 3）getters")]),t._v(" "),a("p",[t._v("有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数。此时可以用到getters，getters可以看作是store的计算属性，其参数为state。")]),t._v(" "),a("h4",{attrs:{id:"_4-mutations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-mutations"}},[t._v("#")]),t._v(" 4）mutations")]),t._v(" "),a("p",[t._v("mutations里面是如何更改state中状态的逻辑。更改Vuex中的state的唯一方法是，提交mutation，即store.commit(‘increment’)。")]),t._v(" "),a("h4",{attrs:{id:"_5-actions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-actions"}},[t._v("#")]),t._v(" 5）actions")]),t._v(" "),a("p",[t._v("因为mutations中只能是同步操作，但是在实际的项目中，会有异步操作，那么actions就是为了异步操作而设置的。这样，就变成了在action中去提交mutation，然后在组件的methods中去提交action。只是提交actions的时候使用的是dispatch函数，而mutations则是用commit函数。")]),t._v(" "),a("p",[t._v("因为action是异步的，那么我们需要知道这个异步函数什么时候结束，以及等到其执行后，会利用某个action的结果。这个可以使用promise来实现。在一个action中返回一个promise，然后使用then()回调函数来处理这个action返回的结果")])])}),[],!1,null,null,null);s.default=r.exports}}]);