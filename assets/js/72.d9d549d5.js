(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{579:function(e,t,r){"use strict";r.r(t);var v=r(6),a=Object(v.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"v-model的原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#v-model的原理"}},[e._v("#")]),e._v(" v-model的原理")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("v-model其实是一个语法糖，它的背后本质上包含两个操作：")])]),e._v(" "),r("li",[r("ul",[r("li",[e._v("1、v-bind绑定一个value属性")]),e._v(" "),r("li",[e._v("2、v-on指令给当前元素绑定input事件")])])])]),e._v(" "),r("p",[e._v("new Vue一个实例对象a，其中有一个属性a.b，那么在实例化的过程中，通过Object.defineProperty()会对a.b添加getter和setter，同时Vue.js会对模板做编译，解析生成一个指令对象（这里是v-text指令），每个指令对象都会关联一个Watcher,当对a.b求值的时候，就会触发它的getter，当修改a.b的值的时候，就会触发它的setter，同时会通知被关联的Watcher，然后Watcher就会再次对a.b求值，计算对比新旧值，当值改变了，Watcher就会通知到指令，调用指令的update()方法，由于指令是对DOM的封装，所以就会调用DOM的原生方法去更新视图，这样就完成了数据改变到视图更新的一个自动过程")]),e._v(" "),r("p",[e._v("具体步骤如下：")]),e._v(" "),r("p",[e._v("● 首先，需要对observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter  getter。这样的话，给这个对象的某个属性赋值，就会触发setter，那么就能监听到数据变化。（其实是通过Object.defineProperty()实现监听数据变化的）")]),e._v(" "),r("p",[e._v("● 然后，需要compile解析模板指令，将模板中的变量替换成数据，接着初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者。一旦数据有变动，订阅者收到通知，就会更新视图")]),e._v(" "),r("p",[e._v("● 接着，Watcher订阅者是Observer和Compile之间通信的桥梁，主要负责：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[e._v("     1）在自身实例化时，往属性订阅器（Dep）里面添加自己\n\n     2）自身必须有一个update()方法\n\n     3）待属性变动，dep.notice()通知时，就调用自身的update()方法，并触发Compile中绑定的回调\n")])])]),r("p",[e._v("● 最后，viewmodel(vue实例对象)作为数据绑定的入口，整合Observer、Compile、Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 (ViewModel)-》视图更新(view)；视图变化(view)-》数据(ViewModel)变更的双向绑定效果。")])])}),[],!1,null,null,null);t.default=a.exports}}]);