(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{551:function(a,s,t){"use strict";t.r(s);var e=t(6),i=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"es6异步编程之promise-async和await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6异步编程之promise-async和await"}},[a._v("#")]),a._v(" ES6异步编程之promise,async和await")]),a._v(" "),t("h3",{attrs:{id:"什么是async-await-及其如何工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是async-await-及其如何工作"}},[a._v("#")]),a._v(" **什么是async/await **及其如何工作？")]),a._v(" "),t("p",[a._v("async/await 是 JS 中编写异步或非阻塞代码的新方式。")]),a._v(" "),t("p",[a._v("它建立在 Promises 之上， 让异步代码的可读性和简洁度都更高。")]),a._v(" "),t("p",[a._v("async 关键声明函数会隐式返回一个 Promise。")]),a._v(" "),t("p",[a._v("await 关键字只能在 async function中使用，在仁和非 async function 的函数中使用 await 关键字都会抛出错误。await 关键字在执行下一行代码之前等待右侧表达式（可能是一个 Promise）返回.")]),a._v(" "),t("h3",{attrs:{id:"promise和async-await以及它们之间的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise和async-await以及它们之间的区别"}},[a._v("#")]),a._v(" Promise和async await以及它们之间的区别")]),a._v(" "),t("p",[a._v("promise 共有三个状态: pending（执行中）、success（成功）、rejected（失败）")]),a._v(" "),t("p",[a._v("async、await 是将异步强行转换为同步处理。")]),a._v(" "),t("p",[a._v("async/await 与 promise 不存在谁代替谁的说法，因为 async/await 是寄生于 Promise，Generater 的语法糖。")]),a._v(" "),t("p",[a._v("区别")]),a._v(" "),t("p",[a._v("async/await 相对于 promise 来讲，写法更加优雅")]),a._v(" "),t("p",[a._v("reject 状态：")]),a._v(" "),t("p",[a._v("promise 错误可以通过 catch 来捕捉，建议尾部捕获错误")]),a._v(" "),t("p",[a._v("async/await 既可以用.then 又可以用 try-catch 捕捉")]),a._v(" "),t("p",[t("strong",[a._v("async")]),a._v(" "),t("strong",[a._v("函数的基本用法")])]),a._v(" "),t("p",[a._v("asyn 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。函数前面的 async 关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个 Promise 对象。由于 async 函数返回的是Promise 对象，可以作为 await 命令的参数。")])])}),[],!1,null,null,null);s.default=i.exports}}]);