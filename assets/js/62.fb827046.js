(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{568:function(e,t,n){"use strict";n.r(t);var a=n(6),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"组件间通信"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#组件间通信"}},[e._v("#")]),e._v(" 组件间通信")]),e._v(" "),n("p",[e._v("组件间通信是我们在 Vue 项目中不可避免的问题，深刻了解了 Vue 组件间通信的几种方式，才能让我们在处理各种交互问题时游刃有余。")]),e._v(" "),n("h3",{attrs:{id:"props"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#props"}},[e._v("#")]),e._v(" Props")]),e._v(" "),n("p",[e._v("Vue 中，最基本的通信方式就是 Props，它是父子组件通信中父组件传值给子组件的一种方式。它允许以数组形式接收，但是更推荐你开启类型检查的形式。更详细的类型检查前往 "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components-props.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue 文档"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// communication.vue\n<communication-sub v-bind="dataProps"></communication-sub>\n// v-bind="dataProps" 等同于 :title="title"，适用于多个参数一起传递\n···\ndata() {\n    return {\n        dataProps: {\n            title: \'我是父组件的值\',\n        }\n    }\n}\n// communication-sub.vue\n<div class="communication-sub">\n    {{title}}\n</div>\n···\nprops: [\'title\']\n// 更推荐开启类型检查\nprops: {\n    title: {\n        type: String,\n        required: true,\n        default: \'\' // 允许指定默认值，引用类型需要函数返回\n    }\n}\n···\n')])])]),n("p",[e._v("我们都知道，Props 是单向数据流，这是 Vue 为了避免子组件意外改变父组件的状态，从而导致数据流向难以理解而做出的限制。所以 Vue 推荐需要改动的时候，通过改变父组件的值从而触发 Props 的响应。或者，我们可以在接收非引用类型的值时，使用子组件自身的 data 做一次接收。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("props: ['title'],\ndata: function () {\n  return {\n    text: this.title\n  };\n}\n")])])]),n("p",[e._v("为什么是非引用类型呢，因为在 JavaScript 中，引用类型的赋值，实际是内存地址的传递。所以上面栗子中的简单赋值，显然会指向同一个内存地址，所以如果是数组或是对象，你可能需要一次深拷贝。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let obj = JSON.parse(JSON.stringify(obj));\n")])])]),n("p",[e._v("上面这个操作有一些缺陷，不能序列化函数、undefined、循环引用等，详见"),n("a",{attrs:{href:"https://www.jianshu.com/p/b084dfaad501",target:"_blank",rel:"noopener noreferrer"}},[e._v("传送门"),n("OutboundLink")],1),e._v("，但是也能应付一些日常情况了。")]),e._v(" "),n("p",[e._v("事实上，在 Props 是引用类型时，单独修改对象、数组的某个属性或下标，Vue 并不会抛出错误。当然，前提是你要非常清楚自己在做什么，并写好注释，防止你的小伙伴们疑惑。")]),e._v(" "),n("p",[e._v("有的同学可能知道，在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到组件的根元素上去。还是之前的栗子：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<communication-sub v-bind="dataProps" class="one" type="div"></communication-sub>\n')])])]),n("p",[e._v("结果如下：")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://camo.githubusercontent.com/71bbba9be61a817e41350989caa5bfd87027b336bf0b69641702796d3df55aa7/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32332f313639616163376162333639353064323f773d37303026683d373126663d706e6726733d33393030",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://camo.githubusercontent.com/71bbba9be61a817e41350989caa5bfd87027b336bf0b69641702796d3df55aa7/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32332f313639616163376162333639353064323f773d37303026683d373126663d706e6726733d33393030",alt:"img"}}),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("这是 Vue 默认处理的，而且，除了 class 和 style 采用合并策略，其它特性（如上栗 type）会替换掉原来根元素上的属性值。当然，我们也可以显示的在组件内部关闭掉这个特性：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("...\ninheritAttrs: false,\nprops: ['title']\n")])])]),n("p",[e._v("利用 inheritAttrs，我们还可以方便的把组件绑定的其它特性，转移到我们指定的元素上。这就需要用到下一个我们要讲的 "),n("code",[e._v("$attrs")]),e._v(" 了。")]),e._v(" "),n("h3",{attrs:{id:"attrs、listeners"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#attrs、listeners"}},[e._v("#")]),e._v(" attrs、listeners")]),e._v(" "),n("p",[e._v("我们在使用组件库的时候经常会这么写：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<el-input v-model="input" placeholder="请输入内容"></el-input>\n')])])]),n("p",[e._v("实际渲染后：")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://camo.githubusercontent.com/99afb858b921d6ecca4d682bd08c4d4bc93c669d12697472a67a9d7cacbc31a4/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32332f313639616164376263353163613535353f773d36343526683d31393026663d706e6726733d35303530",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://camo.githubusercontent.com/99afb858b921d6ecca4d682bd08c4d4bc93c669d12697472a67a9d7cacbc31a4/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32332f313639616164376263353163613535353f773d36343526683d31393026663d706e6726733d35303530",alt:"img"}}),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("可以看到我们指定的的 placeholder 是渲染在 input 上的，但是 input 并不是根元素。难道都用 Props 声明后，再赋值给 input？这种情况就可以用到 "),n("code",[e._v("$attrs")]),e._v(" 了，改造一下我们之前那个栗子。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// communication.vue\n<template>\n    <div class="communication">\n        <communication-sub v-bind="dataProps" class="input" type="text" placeholder="请输入内容">\n        </communication-sub>\n    </div>\n</template>\n<script>\nimport communicationSub from \'./communication-sub.vue\';\nexport default{\n    name: \'communication\',\n    data() {\n        return {\n            dataProps: {\n                title: \'我是 communication 的值\',\n            }\n        }\n    },\n    components: {\n        communicationSub\n    }\n}\n<\/script>\n\n// communication-sub.vue\n···\n<div class="communication-sub">\n    <input v-bind="$attrs" v-model="title"></input>\n</div>\n···\n export default {\n    inheritAttrs: false\n}\n')])])]),n("p",[n("a",{attrs:{href:"https://camo.githubusercontent.com/abbaa7d59781d42b708070e1689ce6aee49e7bef7a38802b5cffc0e508cb649f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32332f313639616234356635393037663835613f773d36333026683d323926663d706e6726733d32373435",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://camo.githubusercontent.com/abbaa7d59781d42b708070e1689ce6aee49e7bef7a38802b5cffc0e508cb649f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32332f313639616234356635393037663835613f773d36333026683d323926663d706e6726733d32373435",alt:"img"}}),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("可以看到，type 已经转移到了子元素 input 标签上，但是 class 没有。这是因为 "),n("code",[e._v("inheritAttrs: false")]),e._v(" 选项不会影响 style 和 class 的绑定。"),n("strong",[e._v("可以看出 "),n("code",[e._v("$attrs")]),e._v(" 则是将没有被组件内部 Props 声明的传值（也叫非 Props 特性）收集起来的一个对象")]),e._v("，再通过 v-bind 将其绑定在指定元素上。这也是 Element 等组件库采用的策略。")]),e._v(" "),n("p",[n("strong",[e._v("这里需要注意一点，通过 $attrs 指定给元素的属性，不会与该元素原有属性发生合并或替换，而是以原有属性为准")]),e._v("。举个例子，假如我将上述 input 的 type 默认设置为 password。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<input v-bind="$attrs" v-model="title" type="password"></input>\n')])])]),n("p",[e._v("则不会采用 $attrs 中的 type: 'text'，将以 password 为准，所以如果需要默认值的属性，建议不要用这种方式。")]),e._v(" "),n("p",[n("code",[e._v("$listeners")]),e._v(" 同 "),n("code",[e._v("$attrs")]),e._v(" 类似，"),n("strong",[e._v("可以看做是一个包含了组件上所有事件监听器（包括自定义事件、不包括.native修饰的事件）的对象")]),e._v("。它也支持上述的写法，适用于将事件安放于组件内指定元素上。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// communication.vue\n<communication-sub v-bind="dataProps"\nclass="input"\ntype="text"\nplaceholder="请输入内容"\n@focus="onFocus" >\n</communication-sub>\n···\nmethods: {\n    onFocus() {\n        console.log(\'onFocus\');\n    }\n}\n// communication-sub.vue\n<input v-bind="$attrs" v-model="title" v-on="$listeners"></input>\n')])])]),n("p",[e._v("给之前的栗子绑定一个聚焦事件，在子组件中通过 "),n("code",[e._v("$listeners")]),e._v(" 绑定给 input，则会在 input 聚焦时触发。")]),e._v(" "),n("p",[e._v("那么除了用在这种给组件内指定元素绑定特性和事件的情况，还有哪些场景可以用到呢？官方说明：在创建更高层次的组件时非常有用。比如在祖孙组件中传递数据，在孙子组件中触发事件后要在祖辈中做相应更新。我们继续之前的栗子：在孙辈组件触发点击事件，然后在祖辈中修改相应的 data。")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://camo.githubusercontent.com/5ba910746895be6158c82f5f5215726667c2f27b3ab0e07b0bcf2192dbc4a72b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32342f313639616236366633623239636633393f773d3130383426683d31373226663d67696626733d3136323031",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://camo.githubusercontent.com/5ba910746895be6158c82f5f5215726667c2f27b3ab0e07b0bcf2192dbc4a72b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32342f313639616236366633623239636633393f773d3130383426683d31373226663d67696626733d3136323031",alt:"img"}}),n("OutboundLink")],1)]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// communication.vue\n<communication-sub v-bind="dataProps"\n                @click="onCommunicationClick">\n</communication-sub>\n···\nmethods: {\n    onCommunicationClick() {\n        this.dataProps.title = \'我是点击之后的值\';\n    }\n};\n\n// communication-sub.vue\n<communication-min-sub v-on="$listeners"></communication-min-sub> // 子组件中将事件透传到孙辈\n\n// communication-min-sub.vue\n<template>\n    <div class="communication-min-sub">\n        <p>我是 communication-min-sub</p>\n        <button v-on="$listeners">click</button>\n    </div>\n</template>\n<script>\nexport default{\n    name: \'communication-min-sub\',\n    inheritAttrs: false\n}\n<\/script>\n')])])]),n("p",[e._v("这样就能很方便的在多级组件的子级组件中，快速访问到父组件的数据和方法。正如在刚才的例子中，button 点击时，是直接调用的 communication.vue 中定义的方法。")]),e._v(" "),n("h3",{attrs:{id:"依赖注入-provide、inject"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入-provide、inject"}},[e._v("#")]),e._v(" 依赖注入 provide、inject")]),e._v(" "),n("p",[e._v("上面的方法，在大多数多级组件嵌套的场景很有用，但有时我们遇到的并不一定是有父子关系的组件。比如基础组件中的 Select 下拉选择器。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<el-select v-model="value" placeholder="请选择">\n    <el-option\n      v-for="item in options"\n      :key="item.value"\n      :label="item.label"\n      :value="item.value">\n    </el-option>\n</el-select>\n')])])]),n("p",[e._v("相信大家都使用过上栗或者类似于上栗的基础组件，它们借助 vue "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components-slots.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("插槽"),n("OutboundLink")],1),e._v(" 实现。所以这个时候，el-select 和 el-option 之间的数据通信，我们之前的 "),n("code",[e._v("$attrs")]),e._v("、"),n("code",[e._v("$listeners")]),e._v("就没有用武之地了。有同学可能不太理解上面的代码为什么要通信，我简单介绍一下 Element 的处理方式：")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://camo.githubusercontent.com/7b7cbfe334b3d6f14f95520503c5de7ec78462943520e9d9b046051f6c4ee7a1/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32342f313639616431633761363333633166313f773d35373226683d33333026663d706e6726733d37353331",target:"_blank",rel:"noopener noreferrer"}},[n("img",{attrs:{src:"https://camo.githubusercontent.com/7b7cbfe334b3d6f14f95520503c5de7ec78462943520e9d9b046051f6c4ee7a1/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f32342f313639616431633761363333633166313f773d35373226683d33333026663d706e6726733d37353331",alt:"img"}}),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("我们可以简单的认为（Element 源码比这个要稍复杂，为了方便理解，简化一下，如有需要，可直接前往源码阅读），在 el-select 中有一个 input 元素，el-option 中是一列渲染好的 li。根据需求，我们在选中某个 li 的时候，要通知 input 展示相应的数据。而且我们在实际使用的时候，一般还伴随 el-form、el-form-item等组件，所以迫切需要一种方式:")]),e._v(" "),n("blockquote",[n("p",[e._v("可以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。--- "),n("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#provide-inject",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue 文档"),n("OutboundLink")],1)])]),e._v(" "),n("p",[e._v("有同学可能会想到，这种多级的可以用 Vuex、EventBus等方式，当然可以。只不过我们现在的前提是基础组件，一般第三方组件库是不会增加一些额外的依赖的。事实上 Vue 本身并不推荐直接在业务中使用 provide、inject，一般在组件、插件库用到的比较多。")]),e._v(" "),n("p",[e._v("但是在项目比较小、业务逻辑比较简单的时候，我们完全不必特意引入 Vuex。只要使用得当，provide、inject 确实不失为一种好办法。说了这么多，我们来看一下具体用法，我们将之前的栗子，改为用 provide、inject 来实现。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// communication.vue\n<communication-sub v-bind="dataProps" >\n</communication-sub>\n// @click="onCommunicationClick" 移除之前绑定的时间\n···\n// 在 provide 添加子代需要接收的方法 onCommunicationClick，\n// 也可以直接指定为 this，子代便能访问父代所有的数据和方法。\nprovide: function () {\n    return {\n        onCommunicationClick: this.onCommunicationClick\n    }\n},\nmethods: {\n    onCommunicationClick() {\n        this.dataProps.title = \'我是点击之后的值\';\n    }\n};\n\n// communication-sub.vue\n<communication-min-sub></communication-min-sub>\n// 移除之前的 v-on="$listeners"，因为在这个组件中不需要用到父组件的方法，所以不用做其它处理\n\n// communication-min-sub.vue\n<template>\n    <div class="communication-min-sub">\n        ···\n        <button @click="onCommunicationClick">click</button>\n        // 移除 v-on="$listeners"，然后绑定 inject 接收到的方法\n    </div>\n</template>\n<script>\nexport default{\n    name: \'communication-min-sub\',\n    inject: [\'onCommunicationClick\'] // inject 接收父组件的方法\n}\n<\/script>\n')])])]),n("p",[e._v("这种写法和之前的 $listeners 得到的效果是一样的，就不再放图了。大家可以自己尝试一下，也可以前往源码 "),n("a",{attrs:{href:"https://github.com/wuyawei/webrtc-stream",target:"_blank",rel:"noopener noreferrer"}},[e._v("webrtc-stream"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("p",[n("strong",[e._v("思考")]),e._v("：有些同学可能会想到，如果我在根实例，app.vue 中如此设置：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<script>\n  export default {\n    provide () {\n      return {\n        app: this // 设置app为this\n      }\n    },\n    data () {\n      return {\n        userInfo: null,\n        otherState: null\n      }\n    }\n  }\n<\/script>\n")])])]),n("p",[e._v("那这样把所有的状态管理都放在 app.data 中，所有的子代中不就可以共享了吗？是不是就不需要 Vuex 了呢？实际上，Vue 本身就提供了一个方法来访问根实例 "),n("code",[e._v("$root")]),e._v("，所以即使没有 provide 也是可以做到的。那为什么不这么用呢？还是前面提到的原因，不利于追踪维护，也失去了所谓状态管理的意义。不过，如果你的项目足够小的话，依然可以这么使用。")]),e._v(" "),n("h3",{attrs:{id:"ref、parent、children"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ref、parent、children"}},[e._v("#")]),e._v(" ref、parent、children")]),e._v(" "),n("p",[e._v("我们前面一直说的都是子组件如何触达父组件，那么父组件能不能访问到子组件呢？当然是可以的。")]),e._v(" "),n("ul",[n("li",[e._v("ref")])]),e._v(" "),n("p",[e._v("简单来说就是获取元素的 Dom 对象和子组件实例。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。获取 Dom 元素就是为了进行一些 Dom 操作，需要注意的一点就是，"),n("strong",[e._v("要在 Dom 加载完成后使用")]),e._v("，否则可能获取不到。比如我要将之前 input 的字体颜色改成红色：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<input type="text" v-model="dataProps.title" ref="input">\n...\nmounted() {\n    this.$nextTick(_ => { // 确保 Dom 更新完成\n        this.$refs[\'input\'].style.color = \'red\';\n    });\n}\n// 这里只是举一个栗子，实际项目中的需求，最好通过 class 的方式，尽量减少 Dom 操作。\n')])])]),n("p",[e._v("那什么情况下需要获取组件实例呢？比如父元素的某个状态改变，需要子组件进行 http 请求更新数据。通常情况下，我们会选择通过 Props 将状态传递给子组件，然后子组件进行 Watch 监测，如果有变更，则进行相应操作。这个时候，我们便可以选择使用 ref。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<child ref=\"child\"></child>\n···\n<script>\n  export default {\n    methods () {\n      onStateChange() { // 变更状态后直接调用子组件方法进行更新\n          this.$refs['child'].updateData();\n      }\n    }\n  }\n<\/script>\n")])])]),n("ul",[n("li",[n("code",[e._v("$children")]),e._v("、"),n("code",[e._v("$parent")])])]),e._v(" "),n("p",[e._v("无独有偶，"),n("code",[e._v("$children")]),e._v(" 同样可以完成上面的任务。"),n("code",[e._v("$children")]),e._v(" 和 "),n("code",[e._v("$parent")]),e._v("，顾名思义，一个会找到当前组件的子组件，一个会找到当前组件的父组件。如果有多个子组件，需要依赖组件实例的 name 属性。改写一下上面的方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<script>\n  export default {\n    methods () {\n      onStateChange() { // 子组件返回的是一个数组，多个子组件用 $options.name 区分。\n          this.$children[0].updateData();\n      }\n    }\n  }\n<\/script>\n")])])]),n("p",[n("code",[e._v("$parent")]),e._v(" 和 "),n("code",[e._v("$children")]),e._v(" 用法一样，不过 "),n("code",[e._v("$parent")]),e._v(" 返回的父组件实例，不是数组，因为父组件肯定只有一个。ref、parent、children 它们几个的一个缺点就是无法处理跨级组件和兄弟组件，后续我们会介绍 dispatch 和 broadcast 方法，实现跨级通信。")]),e._v(" "),n("h3",{attrs:{id:"emit、on、off"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#emit、on、off"}},[e._v("#")]),e._v(" emit、on、off")]),e._v(" "),n("p",[n("code",[e._v("$emit")]),e._v("，想必大家都非常熟悉，我们通常用作父子组件间通信，我们也叫它自定义事件。"),n("code",[e._v("$emit")]),e._v(" 和 "),n("code",[e._v("$on")]),e._v("都是组件自身的方法，"),n("code",[e._v("$on")]),e._v(" 可以监听 "),n("code",[e._v("$emit")]),e._v(" 派发的事件，"),n("code",[e._v("$off")]),e._v(" 则用来取消事件监听。这也是我们下一个要讲的通信方式 EventBus 所依赖的原理。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 父组件\n<template>\n    <button-component @clickButton=\"clickButton\"></button-component>\n    // 在父组件利用 v-on 监听\n</template>\n<script>\nexport default {\n    methods: {\n      clickButton () { ··· }\n    }\n}\n<\/script>\n\n// 子组件\n<template>\n    <button @click=\"handleClick\"></button>\n</template>\n<script>\nexport default {\n    methods: {\n      handleClick () { // 触发 $emit\n        this.$emit('clickButton');\n      }\n    },\n    mounted() {\n        this.$on('clickButton', (...arr) => { // 也可以自己监听 $emit，虽然没什么用···\n            console.log(...arr);\n        })\n    }\n}\n<\/script>\n")])])]),n("h3",{attrs:{id:"eventbus"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#eventbus"}},[e._v("#")]),e._v(" EventBus")]),e._v(" "),n("p",[n("code",[e._v("$emit")]),e._v("的痛点依然是不支持跨级和兄弟组件，Vue 官方推荐我们使用一个新的 Vue 实例来做一个全局的事件通信（或者叫中央事件总线···），也就是我们要讲的 EventBus。了解过的同学都知道，正常的 bus，我们一般会挂载到 Vue 的 prototype 上，方便全局调用。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// main.js\nVue.prototype.$bus = new Vue();\n")])])]),n("p",[e._v("依旧改写之前的栗子：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\x3c!--communication.vue--\x3e\n<communication-sub v-bind=\"dataProps\" >\n</communication-sub>\n···\nbeforeDestroy() { \x3c!-- 实例销毁时，需要卸载监听事件 --\x3e\n    this.$bus.$off('busClick');\n},\ncreated() {  \x3c!-- 监听子组件触发的 Bus 事件--\x3e\n    this.$bus.$on('busClick', (data) => {\n        this.dataProps.title = data;\n    });\n}\n\n\x3c!--communication-min-sub.vue--\x3e\n<template>\n    <div class=\"communication-min-sub\">\n        <button @click=\"busClick\">click bus</button>\n        \x3c!--子组件触发点击事件--\x3e\n    </div>\n</template>\n<script>\nexport default{\n    methods: {\n        busClick() {\n            this.$bus.$emit('busClick', 'bus 触发了');\n        }\n    }\n}\n<\/script>\n")])])]),n("p",[e._v("这是一个基础的 EventBus 的实现。现在我们设想一下，类似于 userInfo 这样的信息，在很多页面都需要用到，那我们需要在许多页面都做 "),n("code",[e._v("$on")]),e._v(" 监听的操作。那能否将这些操作整合到一起呢？我们一起来看：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" // 新建一个 eventBus.js\nimport Vue from 'vue';\nconst bus = new Vue({\n    data () {\n        return {\n            userInfo: {}\n        }\n    },\n    created () {\n        this.$on('getUserInfo', val => {\n            this.userInfo = val;\n        })\n    }\n});\nexport default bus;\n// main.js\nimport bus from './eventBus';\nVue.prototype.$bus = bus;\n// app.vue\nmethods: {\n    getUserInfo() {\n        ajax.post(***).then(data => {\n            this.$bus.$emit('getUserInfo', data); // 通知 EventBus 更新 userInfo\n        })\n    }\n}\n")])])]),n("p",[e._v("这样在其他页面用到 userInfo 的时候，只需要 "),n("code",[e._v("this.$bus.userInfo")]),e._v(" 就可以了。注意刚刚其实没有用 off 卸载掉监听，因为其实 userInfo 这种全局信息，并没有一个准确的说要销毁的时机，浏览器关闭的时候，也用不着我们处理了。但是，如果只是某个页面组件用到的，建议还是用最开始的方法，在页面销毁的时候卸载掉。")]),e._v(" "),n("p",[e._v("不过反过来讲，既然用到了 EventBus，说明状态管理并不复杂，否则还是建议用 Vuex 来做。最后再给大家推荐一篇文章 "),n("a",{attrs:{href:"https://juejin.im/post/5b45971ff265da0f9c678b55",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue中eventbus很头疼？我来帮你"),n("OutboundLink")],1),e._v("，作者处理 EventBus 的思路很巧妙，大家不妨仔细看看。")]),e._v(" "),n("h3",{attrs:{id:"派发与广播-dispatch-与-broadcast"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#派发与广播-dispatch-与-broadcast"}},[e._v("#")]),e._v(" 派发与广播：dispatch 与 broadcast")]),e._v(" "),n("blockquote",[n("p",[e._v("此部分参考自 "),n("a",{attrs:{href:"https://github.com/ElemeFE/element/blob/dev/src/mixins/emitter.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("Element 源码"),n("OutboundLink")],1)])]),e._v(" "),n("p",[e._v("如果有接触过 Vue.js 1.x 的同学，应该对此有所了解。在 1.x 的实现中，是有 "),n("code",[e._v("$dispatch")]),e._v(" 和 "),n("code",[e._v("$broadcast")]),e._v(" 方法的。"),n("code",[e._v("$dispatch")]),e._v(" 的主要作用是向上级组件派发事件，"),n("code",[e._v("$broadcast")]),e._v(" 则是向下级广播。它们的优点是都支持跨级，再看一下官方废弃这两个方法的理由：")]),e._v(" "),n("blockquote",[n("p",[e._v("因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。并且 "),n("code",[e._v("$dispatch")]),e._v(" 和 "),n("code",[e._v("$broadcast")]),e._v(" 也没有解决兄弟组件间的通信问题。")])]),e._v(" "),n("p",[e._v("可以看到，主要原因是在组件结构扩展后不易理解，以及没有解决兄弟组件通信的问题。但是对于组件库来说，这依旧是十分有用的，所以它们大多自己实现了这两个方法。对我们来讲，也许在项目中用不到，但学习这种解决问题的思路，是十分必要的。")]),e._v(" "),n("p",[e._v("派发和广播，依赖于组件的 name（最怕此处有人说：如果不写 name，这方法不就没用了？2333···），以此来逐级查找对应的组件实例。Element 的实现中，给所有的组件都加了一个 componentName 属性，所以它是根据 componentName 来查找的。我们在实现的时候还是直接用 name。")]),e._v(" "),n("p",[e._v("我们先来看一下 "),n("code",[e._v("$dispatch")]),e._v(" 的简单用法，再来分析思路。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\x3c!--communication-min-sub.vue--\x3e\n<template>\n  <button @click=\"handleDispatch\">dispatch</button>\n</template>\n<script>\nimport Emitter from '../../utils/emitter';\nexport default {\n  mixins: [Emitter], // 混入，方便直接调用\n  methods: {\n    handleDispatch () {\n      this.dispatch('communication', 'onMessage', '触发了dispatch');\n    }\n  }\n}\n<\/script>\n\x3c!--communication.vue--\x3e\n<script>\n  export default {\n    beforeDestroy() { // 销毁\n        this.$off('onMessage');\n    },\n    mounted () {\n        this.$on('onMessage', (data) => { // 监听\n            this.dataProps.title = data;\n        })\n    }\n  }\n<\/script>\n")])])]),n("p",[e._v("现在明确一下目标，dispatch 方法接收三个参数，组件 name、事件名称、基础数据（可不传）。要做到向上跨级派发事件，需要向上找到指定 name 的组件实例，利用我们前文提到的 "),n("code",[e._v("$emit")]),e._v("方法做派送，所以在指定组件就可以用 "),n("code",[e._v("$on")]),e._v(" 来监听了。所以 dispatch 本质上就是向上查找到指定组件并触发其自身的 "),n("code",[e._v("$emit")]),e._v("，以此来做响应，broadcast 则相反。那么如何做到跨级查找呢？")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function broadcast(componentName, eventName, params) {\n  this.$children.forEach(child => { // 遍历所有的 $children\n    var name = child.$options.name; // 拿到实例的name，Element 此处用的 componentName\n    if (name === componentName) { // 如果是想要的那个，进行广播\n      child.$emit.apply(child, [eventName].concat(params));\n    } else { // 不是则递归查找 直到 $children 为 []\n      broadcast.apply(child, [componentName, eventName].concat([params]));\n    }\n  });\n}\nexport default {\n  methods: {\n    dispatch(componentName, eventName, params) {\n      var parent = this.$parent || this.$root;\n      var name = parent.$options.name;\n      while (parent && (!name || name !== componentName)) {\n      // 存在 parent 且 (不存在 name 或 name 和 指定参数不一样) 则继续查找\n        parent = parent.$parent; // 不存在继续取上级\n        if (parent) {\n          name = parent.$options.name; // 存在上级 再次赋值并再次循环，进行判断\n        }\n      }\n      if (parent) { // 找到以后 如果有 进行事件派发\n        parent.$emit.apply(parent, [eventName].concat(params));\n      }\n    },\n    broadcast(componentName, eventName, params) {\n      broadcast.call(this, componentName, eventName, params);\n    }\n  }\n};\n")])])]),n("p",[e._v("以上是详细的 emitter.js，可以看见，这和我们之前讲到的 "),n("code",[e._v("$parent")]),e._v("、"),n("code",[e._v("$children")]),e._v("、"),n("code",[e._v("$emit")]),e._v("、"),n("code",[e._v("$on")]),e._v("都密切相关。这也是为什么把它放到后面讲的原因。之前说过，派发和广播并没有解决兄弟组件通信的问题，所以这里大家也可以拓展思考一下，如何支持兄弟组件间通信。依然是依赖于"),n("code",[e._v("$parent")]),e._v("、"),n("code",[e._v("$children")]),e._v("，可以找到任意指定组件。")]),e._v(" "),n("h3",{attrs:{id:"vuex"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[e._v("#")]),e._v(" Vuex")]),e._v(" "),n("blockquote",[n("p",[e._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。--- "),n("a",{attrs:{href:"https://vuex.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),n("OutboundLink")],1)])]),e._v(" "),n("p",[e._v("Vuex 相信大家都比较熟悉了，我不打算在这里把 API 再演示一遍。因为我觉得，官方文档 已经非常详细了。Vuex 的核心是单向数据流，并以相应规则保证所有的状态管理都可追踪、可预测。")]),e._v(" "),n("p",[e._v("我们需要知道什么时候该用 Vuex，如果你的项目比较小，状态管理比较简单，完全没有必要使用 Vuex，你可以考虑我们前文提到的几种方式。")]),e._v(" "),n("p",[n("strong",[e._v("父组件和子组件的执行顺序")]),e._v("？")]),e._v(" "),n("blockquote",[n("p",[e._v("A：父beforeCreate-> 父created -> 父beforeMounte -> 子beforeCreate ->子create ->子beforeMount ->子 mounted -> 父mounted")])]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("p",[e._v("本期文章内容到这里就讲完了，我们来总结回顾一下：")]),e._v(" "),n("ul",[n("li",[e._v("子组件触达父组件的方式：Props、"),n("code",[e._v("$parent")]),e._v("、"),n("code",[e._v("$attrs")]),e._v("、"),n("code",[e._v("$listeners")]),e._v("、provide 和 inject、"),n("code",[e._v("$dispatch")])]),e._v(" "),n("li",[e._v("父组件触达子组件的方式："),n("code",[e._v("$emit")]),e._v(" 和 "),n("code",[e._v("$on")]),e._v("、"),n("code",[e._v("$children")]),e._v("、"),n("code",[e._v("$ref")]),e._v("、"),n("code",[e._v("broadcast")])]),e._v(" "),n("li",[e._v("全局通信：EventBus、Vuex")])])])}),[],!1,null,null,null);t.default=s.exports}}]);