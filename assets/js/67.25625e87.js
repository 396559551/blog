(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{573:function(t,h,v){"use strict";v.r(h);var _=v(6),s=Object(_.a)({},(function(){var t=this,h=t.$createElement,v=t._self._c||h;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[v("strong",[t._v("hash")]),t._v(" "),v("strong",[t._v("模式：")])]),t._v(" "),v("p",[t._v("url 的 hash 是以 # 开头，原本是用来作为锚点，从而定位到页面的特定区域。当 hash 改变时，页面不")]),t._v(" "),v("p",[t._v("会因此刷新，浏览器也不会向服务器发送请求。")]),t._v(" "),v("p",[t._v("http://www.xxx.com/#/home")]),t._v(" "),v("p",[t._v("同时， hash 改变时，并会触发相应的 hashchange 事件。所以，hash 很适合被用来做前端路由。当")]),t._v(" "),v("p",[t._v("hash 路由发生了跳转，便会触发 hashchange 回调，回调里可以实现页面更新的操作，从而达到跳转")]),t._v(" "),v("p",[t._v("页面的效果。")]),t._v(" "),v("p",[t._v("hash模式的工作原理是hashchange事件，可以在window监听hash的变化。我们在url后面随便添加一")]),t._v(" "),v("p",[t._v("个#xx触发这个事件。")]),t._v(" "),v("p",[t._v("**history ** "),v("strong",[t._v("模式：")])]),t._v(" "),v("p",[t._v("HTML5 规范中提供了 history.pushState 和 history.replaceState 来进行路由控制。通过这两个方法，")]),t._v(" "),v("p",[t._v("可以实现改变 url 且不向服务器发送请求。同时不会像 hash 有一个 # ，更加的美观。但是 History 路由")]),t._v(" "),v("p",[t._v("需要服务器的支持，并且需将所有的路由重定向到根页面。")]),t._v(" "),v("p",[t._v("History 路由的改变不会去触发某个事件，所以我们需要去考虑如何触发路由更新后的回调。")]),t._v(" "),v("p",[t._v("有以下两种方式会改变 url：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("调用 history.pushState 或 history.replaceState；")])]),t._v(" "),v("li",[v("p",[t._v("点击浏览器的前进与后退。")])])])])}),[],!1,null,null,null);h.default=s.exports}}]);