(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{576:function(t,e,_){"use strict";_.r(e);var v=_(6),c=Object(v.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"nexttick"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nexttick"}},[t._v("#")]),t._v(" nextTick")]),t._v(" "),_("p",[t._v("当dom加载完毕执行内部代码")]),t._v(" "),_("p",[_("strong",[t._v("一、原理")])]),t._v(" "),_("p",[t._v("Vue在修改数据后，视图不会立刻更新，而是等"),_("strong",[t._v("同一事件循环")]),t._v("中的所有数据变化完成之后，再统一进行视图更新")]),t._v(" "),_("h3",{attrs:{id:"二、vue-nexttick-的机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、vue-nexttick-的机制"}},[t._v("#")]),t._v(" 二、Vue.nextTick 的机制")]),t._v(" "),_("p",[_("strong",[t._v("JS执行是单线程的，它是基于事件循环的。")])]),t._v(" "),_("p",[t._v("Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 "),_("code",[t._v("Vue.nextTick()")]),t._v("方法。")]),t._v(" "),_("h3",{attrs:{id:"_3、怎么用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、怎么用"}},[t._v("#")]),t._v(" 3、怎么用")]),t._v(" "),_("p",[_("strong",[t._v("语法")]),t._v("："),_("code",[t._v("Vue.nextTick([callback, context])")])]),t._v(" "),_("p",[_("strong",[t._v("参数")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("{Function} [callback]")]),t._v("：回调函数，不传时提供promise调用")]),t._v(" "),_("li",[_("code",[t._v("{Object} [context]")]),t._v("：回调函数执行的上下文环境，不传默认是自动绑定到调用它的实例上。")])]),t._v(" "),_("p",[t._v("Vue实例方法"),_("code",[t._v("vm.$nextTick")]),t._v("做了进一步封装，把context参数设置成当前Vue实例。")]),t._v(" "),_("h3",{attrs:{id:"_4、小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、小结"}},[t._v("#")]),t._v(" 4、小结")]),t._v(" "),_("p",[t._v("使用"),_("code",[t._v("Vue.nextTick()")]),t._v("是为了可以获取更新后的DOM 。\n触发时机：在同一事件循环中的数据变化后，DOM完成更新，立即执行"),_("code",[t._v("Vue.nextTick()")]),t._v("的回调。")]),t._v(" "),_("blockquote",[_("p",[t._v("同一事件循环中的代码执行完毕 -> DOM 更新 -> nextTick callback触发")])])])}),[],!1,null,null,null);e.default=c.exports}}]);