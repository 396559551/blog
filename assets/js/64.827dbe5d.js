(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{569:function(t,e,s){"use strict";s.r(e);var p=s(6),o=Object(p.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("##computed属性\ncomputed和methods比较")]),t._v(" "),s("p",[t._v("两种方法最终结果是相同的。然而，不同的是computed是基于他们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时他们才会重新求值")]),t._v(" "),s("p",[t._v("这就意味着只要messages还没有发生改变，多次访问computed属性会立即返回之前的计算结果，而不必再次执行函数")]),t._v(" "),s("p",[t._v("##监听器和计算属性的比较")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[t._v("####特点和区别：\nvue的computed主要用于同步数据的处理，而watch主要用于事件的派发，可异步")]),t._v(" "),s("p",[t._v("computed拥有缓存属性，只有当依赖的数据发生变化时，关联的数据才会变化，适用于计算或者格式化数据的场景")]),t._v(" "),s("p",[t._v("watch监听数据，有关联但是没有依赖，只要某个数据发生变化，就可以处理一些数据或者派发事件并同步/异步执行")])])])}),[],!1,null,null,null);e.default=o.exports}}]);